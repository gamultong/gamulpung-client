# 타일 렌더링 방법  

이 프로젝트는 애니메이션 효율성을 위해 3개의 `<canvas>` 요소를 사용하여 그래픽을 렌더링합니다:  

1. **타일 캔버스**: 타일을 렌더링.  
2. **상호작용 캔버스**: 커서 경로와 상호작용 범위를 그리기.  
3. **커서 캔버스**: 사용자 커서를 그리기.  

---

## 프레임 생성 방법  

### 0. 시작 및 종료 지점 초기화  

클라이언트의 창 크기와 최초 타일 크기를 기준으로 타일을 초기화하고 시작 및 종료 지점을 설정합니다.  
이는 클라이언트 창에 렌더링할 수 있는 타일 개수를 기준으로 계산됩니다.  
자세한 내용은 `play/page.tsx`에서 확인할 수 있습니다.  

---

### 1. 서버에 연결  

이 Hook은 WebSocket이 열려 있지 않고 시작 및 종료 지점이 정의된 경우 지정된 URL과 뷰 크기를 사용하여 WebSocket을 재연결 시도합니다.  
자세한 내용은 `play/page.tsx`에서 확인할 수 있습니다.  

---

### 2. WebSocket을 사용하여 서버에서 타일 데이터 가져오기  

타일 및 커서 데이터를 서버에서 가져오려면 WebSocket 연결을 설정하고 들어오는 메시지를 수신 대기합니다. 메시지를 수신하면 데이터를 파싱하고 상태를 업데이트합니다.  

- 시작 및 종료 지점을 기준으로 모든 타일을 요청하고, 초기에는 모든 타일을 "??"로 설정합니다.  

**주의사항**:  
- `start_y`와 `end_y` 좌표는 y축이 반전되어 있으므로 반대로 설정합니다.  
이유: 백엔드는 데카르트 좌표계를 사용, 프론트엔드는 브라우저의 렌더링 방향을 기반으로 잡음.

- 추출된 값을 `replaceTiles` 함수에서 사용해 타일을 업데이트합니다. 
  1. 수신된 헥스 데이터로 이루어진 문자열을 다음과 같이 파싱합니다.
  0 - 열림확인, 1 - 지뢰확인, 2 - 깃발확인, 3 ~ 4 색상(00 red, 01 yellow, 10 blue, 11 purple), 5 ~ 7 지뢰 갯수(000 0개, 010 2개 ... 111 8개)
  2. 한 줄이 다 채워졌다면 다음 줄을 채웁니다.
  3. 모든 줄이 채워졌다면 y축을 반전시키고, 요청한 부분만 타일을 교체합니다.

서버에서 요청된 타일이 전달되면, 더미 데이터 타일을 전달된 타일로 교체합니다.  
자세한 내용은 `play/page.tsx`에서 확인할 수 있습니다.  

---

### 3. Path2D 객체와 폰트 캐싱  

렌더링 성능을 개선하기 위해 Path2D 객체를 캐싱하고, 
초기 폰트 미적용 문제를 예방하기 위해 `fontface.load()`를 사용해 로컬 폰트를 Promise 객체로 로딩될 때까지 기다립니다.
자세한 내용은 `components/canvas/index.tsx`에서 확인할 수 있습니다.  

---

### 4. 캔버스에 타일 렌더링  

모든 속성이 캐싱되면 로딩 상태를 `false`로 설정하고 타일 캔버스에 타일을 렌더링합니다.  
렌더링은 타일 맵, 타일 크기, 커서 위치, 클릭 위치, 색상, 줌 등 속성에 따라 다릅니다.  

- **내 커서 캔버스**
  단순히 클라이언트의 화면 가운데에 클라이언트의 커서를 표시하는 데 사용되는 캔버스입니다.

- **타일 캔버스**:  
  이 캔버스에서는 React-Pixi를 활용한 그래픽입니다.
  - 내부 좌표 정의: 그라디언트를 적용할 영역을 설정.  
  - 타일 텍스쳐
    1. 타일 텍스쳐 생성: 벡터 경로를 그리기 위해 가상의 캔버스를 생성 후 벡터를 그린 후 캔버스를 텍스쳐로 캐싱합니다.
    2. 타일 텍스쳐 캐싱: 타일 크기가 달라질 때 이미 캐싱된 텍스쳐가 있으면 그것을 가져옵니다.
  - 타일 컴포넌트
    1. 타일 컴포넌트 생성: 생성한 텍스쳐를 PIXI.js의 Sprite 컴포넌트를 활용해 렌더링합니다.
    2. 타일 컴포넌트 캐싱: 캐싱되어 있는 타일 스프라이트를 복제합니다.
  - 렌더링 최적화: 텍스쳐를 부드럽게 하는 Antialiasing이 사용되지 않으며, 클라이언트의 움직임이 감지될 때 Resolution(화질)이 낮아집니다. 

- **상호작용 캔버스**:  
  - 클릭된 타일 강조: 클릭된 타일에 테두리를 그려 시각적 피드백 제공.  
  - 클라이언트 커서 경로 그리기: 경로가 존재하면(`paths.length > 0`), 타일 내 중심을 연결하는 선을 그림.  

- **커서 캔버스**:  
  - 캔버스 설정: 다른 사용자 커서를 그리기 위한 캔버스 가져오기.  
  - 이전 그림 지우기: `clearRect`를 사용해 캔버스를 정리.  
  - 커서 그리기:  
    - `cursors` 배열의 각 커서를 순회.  
    - 각 커서의 정확한 위치를 계산.  
    - `drawCursor` 함수를 사용해 위치와 색상이 올바른 커서를 그림.  

- **(40% 미만 제외)클라이언트 움직임으로 인한 캔버스 애니메이션**
  - 내 커서 캔버스를 제외한 모든 캔버스들이 내 커서가 이동함에 따라 타일 상태가 바뀌는 사이 다음 경로를 향해 css transform 효과를 설정합니다.

자세한 코드는 `components/canvas/index.tsx`에서 확인할 수 있습니다.  

---

### 5. 캔버스 업데이트  

다음 이벤트가 발생하면 캔버스를 업데이트해야 합니다:  

#### 5-1. 클라이언트 커서 위치 변경 시  

이전 타일 로드 방식과 유사하게, 이동 방향에 따라 타일을 로드합니다.  
이동 방향 반대쪽에 타일을 밀어내고 빈 공간을 "??"로 채운 후 타일을 로드 및 교체합니다.  

대각선 이동도 동일한 방식으로 처리됩니다. 이동 방향의 타일을 로드하고, 반대 방향의 타일을 밀어낸 후 빈 공간을 채우고 타일을 교체합니다.  

이후 시작 및 종료 지점을 설정하고, 커서 위치를 기준으로 모든 캔버스를 다시 렌더링합니다.  

#### 5-2. 다른 커서 상태 변경 시  

다른 커서 위치를 기준으로 커서 캔버스를 다시 렌더링합니다.  

#### 5-3. 특정 타일이 업데이트된 경우  

해당 타일을 교체하고 모든 캔버스를 다시 렌더링합니다.  
타일 교체시 "??"같은 더미데이터를 사용하지 않고 hex 값을 파싱하여 즉각 반영됩니다.

#### 5-4. 클라이언트가 타일의 크기를 조절한 경우

시작 및 종료 지점을 설정하고, 커서 위치를 기준으로 모든 캔버스를 다시 렌더링합니다.  